<link rel="import" href="common.html">
<script>
function ShadeyCssLexer() {
  'use strict';
  // NOTE(cdata): Generally, tokens are structured as three-valued tuple,
  // where the first value is the token value, the second value is the token
  // type and the third value is the cursor index after consuming the raw
  // source.

  var common = ShadeyCssCommon();
  var matcher = common.matcher;
  var tokenType = common.tokenType;

  function Whitespace(source, offset) {
    var start = offset;

    while (matcher.whitespace.test(source[offset])) {
      ++offset;
    }

    return [
      source.substr(start, offset - start),
      tokenType.whitespace,
      offset
    ];
  }

  function Boundary(source, offset) {
    var token;

    if (matcher.boundary.test(source[offset])) {
      return [
        source[offset],
        tokenType.boundary,
        offset + 1
      ];
    }

    return [
      null,
      tokenType.none,
      offset
    ];
  }

  function StringValue(source, offset) {
    var quotation = source[offset];
    var escaped = false;
    var string = quotation;
    var character;

    if (!matcher.quotation.test(quotation)) {
      throw new Error('Expected quotation mark, but got ' + quotation + ' at ' + offset);
    }

    while (character = source[++offset]) {
      string += character;

      if (escaped) {
        escaped = false;
        continue;
      }

      if (character === quotation) {
        return [
          string,
          tokenType.string,
          offset + 1
        ];
      }

      if (character === '\\') {
        escaped = true;
      }
    }

    return [
      null,
      tokenType.none,
      offset
    ];
  }

  function Word(source, offset) {
    var word = null;
    var character;

    while ((character = source[offset]) && !matcher.boundary.test(character)) {
      word = word || '';
      word += character;
      ++offset;
    }

    return [
      word,
      word == null ? tokenType.none : tokenType.word,
      offset
    ];
  }

  function Token(source, offset) {
    var token = Whitespace(source, offset);

    if (token[0]) {
      return token;
    }

    token = Boundary(source, token[2]);

    switch(token[0]) {
      case null:
        break;
      case '"':
      case '\'':
        return StringValue(source, token[2] - 1);
      default:
        return token;
    }

    return Word(source, token[2]);
  }

  function lex(source) {
    var tokens = [];
    var offset = 0;
    var token;

    while ((token = Token(source, offset)) && token[0] != null) {
      tokens.push(token);
      offset = token[2];
    }

    return tokens;
  }

  return {
    lex: lex
  };
}
</script>
