import { matcher, tokenType } from './common';
import { TokenCursor } from './token-cursor';
import { Lexer } from './lexer';
import { NodeFactory } from './node-factory';

/**
 * Class that implements a CSS parser.
 */
class Parser {
  /**
   * Create a Parser instance. When creating a Parser instance, a specialized
   * NodeFactory can be supplied to implement streaming analysis and
   * manipulation of the CSS AST.
   */
  constructor(nodeFactory = new NodeFactory()) {
    this.nodeFactory = nodeFactory;
  }

  /**
   * Parse CSS and generate an AST.
   * @param {string} cssText The CSS to parse.
   * @return {object} A CSS AST containing nodes that correspond to those
   * generated by the Parser's NodeFactory.
   */
  parse(cssText) {
    return this.parseStylesheet(new TokenCursor(new Lexer(cssText)));
  }

  /**
   * Consumes tokens from a TokenCursor to parse a Stylesheet node.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {object} A Stylesheet node.
   */
  parseStylesheet(tokenCursor) {
    let declarations = [];
    let declaration;

    while (tokenCursor.next &&
           (declaration = this.parseDeclaration(tokenCursor))) {
      declarations.push(declaration);
    }

    return this.nodeFactory.stylesheet(declarations);
  }

  /**
   * Consumes tokens from a TokenCursor to parse declarations, which are any
   * nodes that are not a Stylesheet node.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {object} One of a Comment, AtRule, Selector, Property or Discarded
   * node, or null if no more tokens remain to be parsed.
   */
  parseDeclaration(tokenCursor) {
    // Consume all leading (presumably insignificant) whitespace:
    this.traverseWhitespace(tokenCursor);

    if (tokenCursor.next) {
      // Test for a comment opening. Take a comment as necessary:
      if (matcher.commentOpen.test(tokenCursor.next.text)) {
        return this.parseComment(tokenCursor);
      }

      // Check for an At Rule:
      if (tokenCursor.next.text === '@') {
        return this.parseAtRule(tokenCursor);
      }

      // Everything else is assumed to be a Rule (a Property or a Selector).
      // Make sure we didn't land on an untaken delimiter or an unbalanced
      // brace.
      if (!matcher.propertyDelimiter.test(tokenCursor.next.text) &&
          (tokenCursor.next.type === tokenType.word ||
           tokenCursor.next.type === tokenType.boundary)) {
        return this.parseRule(tokenCursor);
      }

      // Otherwise we handle unknown syntax to the next boundary:
      return this.parseUnknown(tokenCursor);
    }

    // Preferring a default return of `null` for consistency, this implies
    // that we have exhausted our tokens:
    return null;
  }

  /**
   * Consumes tokens from a TokenCursor to parse a Comment node.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {object} A Comment node.
   */
  parseComment(tokenCursor) {
    let comment = '';

    while (tokenCursor.next) {
      let token = tokenCursor.takeOne();
      comment += token.text;

      if (matcher.commentClose.test(token.text)) {
        break;
      }
    }

    return this.nodeFactory.comment(comment)
  }

  /**
   * Consumes tokens from a TokenCursor through the next boundary token to
   * produce a Discarded node. This supports graceful recovery from many
   * malformed CSS conditions.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {object} A Discarded node.
   */
  parseUnknown(tokenCursor) {
    let unknown = '';

    while (tokenCursor.next) {
      let token = tokenCursor.takeOne();

      unknown += token.text;

      if (token && token.type === tokenType.boundary) {
        break;
      }
    }

    unknown += this.traverseDelimiter(tokenCursor);

    return this.nodeFactory.discarded(unknown);
  }

  /**
   * Consumes tokens from a TokenCursor to parse an At Rule node.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {object} An At Rule node.
   */
  parseAtRule(tokenCursor) {
    let whitespace = '';
    let name = '';
    let parameters = '';
    let block;

    while (tokenCursor.next) {
      if (tokenCursor.next.type === tokenType.whitespace) {
        whitespace = this.traverseWhitespace(tokenCursor);
      } else if (!name && tokenCursor.next.text === '@') {
        tokenCursor.takeOne();

        while (tokenCursor.next &&
               tokenCursor.next.type !== tokenType.boundary &&
               tokenCursor.next.type !== tokenType.whitespace) {
          name += tokenCursor.takeOne().text;
        }
      } else if (tokenCursor.next.text === '{') {
        block = this.parseBlock(tokenCursor);
        break;
      } else if (matcher.propertyDelimiter.test(tokenCursor.next.text)) {
        // TODO: why not take one?
        this.traverseDelimiter(tokenCursor);
        break;
      } else {
        if (whitespace && parameters) {
          parameters += whitespace;
        }
        whitespace = '';
        parameters += tokenCursor.takeOne().text;
      }
    }

    return this.nodeFactory.atRule(name, parameters, block);
  }

  /**
   * Consumes tokens from a TokenCursor to produce a Block node.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {object} A Block node.
   */
  parseBlock(tokenCursor) {
    let declarations = [];

    // Take the opening { boundary:
    tokenCursor.takeOne();

    while (tokenCursor.next) {
      if (tokenCursor.next.type === tokenType.whitespace) {
        this.traverseWhitespace(tokenCursor);
      } else if (tokenCursor.next.text === '}') {
        // Take the closing } boundary:
        tokenCursor.takeOne();
        break;
      } else {
        let declaration = this.parseDeclaration(tokenCursor);
        if (declaration == null) {
          break;
        }
        declarations.push(declaration);
      }
    }

    return this.nodeFactory.block(declarations);
  }

  /**
   * Consumes tokens from a TokenCursor instance to produce a Property node or
   * a Selector node, as appropriate.
   * @param {TokenCursor} tokenCursor A TokenCursor node.
   * @return {object} One of a Property or Selector node.
   */
  parseRule(tokenCursor) {
    let rule = '';
    let whitespace = '';

    while (tokenCursor.next) {
      if (tokenCursor.next.type === tokenType.whitespace) {
        whitespace = this.traverseWhitespace(tokenCursor);
      } else if (tokenCursor.next.text === '(') {
        rule += this.traverseCall(tokenCursor);
      } else if (matcher.blockBoundary.test(tokenCursor.next.text)) {
        break;
      } else {
        if (whitespace && rule) {
          rule += whitespace;
        }
        whitespace = '';
        rule += tokenCursor.takeOne().text;
      }
    }

    // A selector never contains or ends with a semi-colon.
    if (matcher.propertyDelimiter.test(tokenCursor.next.text)) {
      let colonIndex = rule.indexOf(':');
      let value = rule.substr(colonIndex + 1).replace(/^\s*/, '');

      this.traverseDelimiter(tokenCursor);

      return this.nodeFactory.property(
          rule.substr(0, colonIndex),
          this.nodeFactory.propertyValue(value));
    } else if (matcher.propertyNameTrail.test(rule)) {
      let block = this.parseBlock(tokenCursor);

      this.traverseDelimiter(tokenCursor);

      return this.nodeFactory.property(rule.substr(0, rule.length - 1), block);
    } else {
      return this.nodeFactory.selector(rule, this.parseBlock(tokenCursor));
    }
  }

  /**
   * Consumes tokens from a TokenCursor until the current parenthesized
   * substring in the token set is consumed.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {string} The parenthesized substring traversed.
   */
  traverseCall(tokenCursor) {
    let call = '';

    if (tokenCursor.next.text === '(') {
      while (tokenCursor.next.text !== ')') {
        call += tokenCursor.takeOne().text;
      }
    }

    return call;
  }

  /**
   * Consumes tokens from a TokenCursor until the current block of whitespace
   * has been consumed.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {string} The whitespace substring traversed.
   */
  traverseWhitespace(tokenCursor) {
    let whitespace = '';

    while (tokenCursor.next &&
           tokenCursor.next.type === tokenType.whitespace) {
      whitespace += tokenCursor.takeOne().text;
    }

    return whitespace;
  }

  /**
   * Consumes tokens from a TokenCursor until all whitespace and the next
   * semi-colon has been consumed.
   * @param {TokenCursor} tokenCursor A TokenCursor instance.
   * @return {string} The whitespace / semi-colon substring traversed.
   */
  traverseDelimiter(tokenCursor) {
    let trail = this.traverseWhitespace(tokenCursor);

    if (tokenCursor.next && tokenCursor.next.text === ';') {
      trail += tokenCursor.takeOne().text;
    }

    return trail;
  }
}

export { Parser };
