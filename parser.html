<link rel="import" href="common.html">
<link rel="import" href="lexer.html">
<script>
function ShadeyCssParser() {
  'use strict';

  var lexer = ShadeyCssLexer();
  var common = ShadeyCssCommon();
  var matcher = common.matcher;
  var tokenType = common.tokenType;

  function Selector(tokens, index) {
    var token = tokens[index];
    var combinator = '';
    var block = null;

    while (!matcher.blockBoundary.test(token[0])) {
      combinator += token[0];
      token = tokens[++index];
    }

    if (token[0] === '{') {
      token = Block(tokens, index);
      block = token[0];
      index = token[1];
    }

    token = Delimiter(tokens, index);
    index = token[1];

    return [{
      type: 'selector',
      combinator: combinator,
      block: block
    }, index];
  }

  function Value(tokens, index) {
    var token = tokens[index];
    var value = '';

    while (matcher.whitespace.test(token[0])) {
      token = tokens[++index];
    }

    if (token[0] === '{') {
      return Block(tokens, index);
    } else {
      while (!matcher.blockBoundary.test(token[0])) {
        value += token[0];
        token = tokens[++index];
      }
    }

    token = Delimiter(tokens, index);
    index = token[1];

    return [{
      type: 'value',
      value: value
    }, index];
  }

  function Property(tokens, index) {
    var token = tokens[index];
    var name = '';
    var value = null;

    while (!matcher.propertyBoundary.test(token[0])) {
      name += token[0];
      token = tokens[++index];
    }

    if (token[0] === ':') {
      token = Value(tokens, index + 1);
      value = token[0];
      index = token[1];
    }

    return [{
      type: 'property',
      name: name,
      value: value
    }, index];
  }

  function Rule(tokens, index) {
    var token = tokens[index];
    var start = index;

    while (!matcher.blockBoundary.test(token[0])) {
      token = tokens[++index];

      if (matcher.propertyDelimiter.test(token[0])) {
        return Property(tokens, start);
      }

      if (matcher.blockBoundary.test(token[0])) {
        return Selector(tokens, start);
      }
    }

    return ParseError(tokens, index, 'Failed to parse Rule starting with ' + tokens[start][0]);
  }

  function Delimiter(tokens, index) {
    var token = tokens[index];

    while (token && matcher.whitespace.test(token[0])) {
      token = tokens[++index];
    }

    if (token && token[0] === ';') {
      token = tokens[++index];
    }

    return [{
      type: 'delimiter',
      value: token ? token[0] : 'EOF'
    }, index];
  }

  function Block(tokens, index) {
    var token = tokens[++index];
    var statements = [];
    var statement;

    while (token && token[0] !== '}') {
      statement = Statement(tokens, index);
      if (statement[0] == null) {
        break;
      }

      statements.push(statement[0]);
      token = Delimiter(tokens, statement[1]);

      index = token[1];
      token = tokens[index];
    }

    token = Delimiter(tokens, index + 1);
    index = token[1];

    return [{
      type: 'block',
      statements: statements
    }, index];
  }

  function AtRule(tokens, index) {
    var token = tokens[index];
    var identifier = token[0];
    var value = '';
    var block;

    token = tokens[++index];

    if (token[1] !== tokenType.word) {
      return ParseError(tokens, index, 'At Rule missing identifier, got "' + token[0] + '" instead');
    }

    identifier += token[0];

    while ((token = tokens[++index]) && !matcher.blockBoundary.test(token[0])) {
      value += token[0];
    }

    if (token[0] === '{') {
      token = Block(tokens, index);
      block = token[0];
      index = token[1];
    }

    token = Delimiter(tokens, index);
    index = token[1];

    return [{
      type: 'at-rule',
      identifier: identifier,
      value: value,
      block: block
    }, index];
  }

  function Comment(tokens, index) {
    var token = tokens[index];
    var comment = token[0];

    while (!matcher.commentClose.test(token[0]) && (token = tokens[++index])) {
      comment += token[0];
    }

    return [{
      type: 'comment',
      value: comment
    }, index + 1];
  }

  function ParseError(tokens, index, error) {
    return [{
      type: 'parse-error',
      offset: tokens[index][2],
      error: error || ''
    }, index];
  }

  function Statement(tokens, index) {
    var token = tokens[index];

    while (token[1] === tokenType.whitespace) {
      token = tokens[++index];
    }

    if (matcher.commentOpen.test(token[0])) {
      return Comment(tokens, index);
    }

    if (token[0] === '@') {
      return AtRule(tokens, index);
    }

    if (token[1] === tokenType.word || token[1] === tokenType.boundary) {
      return Rule(tokens, index);
    }

    return [null, tokens.length];
  }

  function Stylesheet(tokens) {
    var lastIndex;
    var index = 0;
    var parsed = [];
    var statement;

    while (index < tokens.length) {
      statement = Statement(tokens, index);

      if (statement[0] != null) {
        parsed.push(statement[0]);
      }

      lastIndex = index;
      index = statement[1];

      if (index === lastIndex) {
        console.error('Infinite loop detected, breaking.');
        break;
      }
    }

    return parsed;
  }

  function parse(source) {
    return Stylesheet(lexer.lex(source));
  }

  return {
    parse: parse
  };
}
</script>
